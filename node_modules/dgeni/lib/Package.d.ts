import { ProcessorDef } from './Processor';
import { Module, FactoryDef, TypeDef } from './Module';
export declare type PackageRef = Package | string;
/**
 * A Dgeni Package containing processors, services and config blocks.
 * @param {string}   name         The name of the package
 * @param {string[]} dependencies The names of packages (or the actual packages) that this package
 *                                depends upon
 */
export declare class Package {
    name: string;
    dependencies: PackageRef[];
    static isPackage(pkg: any): pkg is Package;
    processors: any[];
    configFns: any[];
    handlers: {
        [key: string]: string[];
    };
    module: Module;
    namedDependencies: string[];
    constructor(name: string, dependencies?: PackageRef[]);
    /**
     * Add a new processor to the package. The processor can be defined by a processor definition object
     * or a factory function, which can be injected with services and will return the processor definition
     * object.  The following properties of a processor definition object have special meaning to Dgeni:
     *
     * * `name : {string}`:  The name of the processor - if the processor is defined by a factory
     * function or a name is explicitly provided as the first parameter, then this is ignored
     * * `$process(docs : {string}) : {Array|Promise|undefined}`: The method that will be called to
     * process the documents. If it is async then it should return a Promise.
     * * `$runAfter : {string[]}`: Dgeni will ensure that this processor runs after those named here.
     * * `$runBefore : {string[]}`: Dgeni will ensure that this processor runs before those named here.
     * * `$validate: {Object}`: Dgeni will check that the properties of the processor, which match the
     * keys of this object, pass the validation rules provided as the values of this object. See
     * http://validatejs.org
     *
     * @param  {function|object|string} processorDefOrName
     * If this parameter is a string then it will be used as the processor's name, otherwise it is
     * assumed that it used as the `processorDef`
     *
     * @param {function|object} processorDef
     * The factory function or object that will be used by the injector to create the processor.
     * * If a function then it is a factory and it must not be anonymous - it must have a name, e.g.
     *   `function myProcessor(dep1, dep2) { ... }` - since the name of the processor is taken from the
     *   name of the factory function.
     * * If an object, then it is the actual processor and must have a `name` property.  In this case,
     *   you cannot inject services into this processor.
     *
     * @return {Package}
     * `this` package, to allow methods to be chained.
     */
    processor(processorDefOrName: string | ProcessorDef, processorDef?: ProcessorDef): this;
    /**
     * Add a new service, defined by a factory function, to the package
     *
     * @param {function|string} serviceFactoryOrName
     * If a string then this is the name of the service, otherwise it is assumed to be the
     * `serviceFactory`.
     *
     * @param  {function} serviceFactory
     * The factory function that will be used by the injector to create the service.  The function must
     * not be anonymous - it must have a name, e.g. `function myService() { ... }` - since the name of
     * the service is taken from the name of the factory function.
     *
     * @return {Package}
     * "This" package, to allow methods to be chained.
     */
    factory(serviceFactoryOrName: string | FactoryDef, serviceFactory?: FactoryDef): this;
    /**
     * Add a new service, defined as a Type to instantiated, to the package
     *
     * @param {function|string} ServiceTypeOrName
     * If a string then this is the name of the service, otherwise it is assumed to be the
     * `ServiceType`.
     *
     * @param  {function} ServiceType
     * The constructor function that will be used by the injector to create the processor.  The function
     * must not be anonymous - it must have a name, e.g. `function MyType() { ... }` - since the name of
     * the service is taken from the name of the constructor function.
     *
     * @return {Package}
     * "This" package, to allow methods to be chained.
     */
    type(ServiceTypeOrName: string | TypeDef, ServiceType?: TypeDef): this;
    /**
     * Add a new config block to the package. Config blocks are run at the beginning of the doc
     * generation before the processors are run.  They can be injected with services and processors
     * to allow you access to their properties so that you can configure them.
     *
     * @param  {function} configFn         The config block function to run
     *
     * @return {Package}
     * "This" package, to allow methods to be chained.
     */
    config(configFn: Function): this;
    /**
     * Add an event handler to this package
     * @param  {string} eventName        The name of the event to handle
     * @param  {function} handlerFactory An injectable factory function that will return the handler
     * @return {Package}                 This package for chaining
     */
    eventHandler(eventName: string, handlerFactory: FactoryDef): this;
}
